<!--
 * @Author: xiuquanxu
 * @Company: kaochong
 * @Date: 2020-03-20 00:01:35
 * @LastEditors: xiuquanxu
 * @LastEditTime: 2020-03-26 23:46:57
 -->
## 堆排序  

堆数据结构是一种数组对象，可以视为一个完全二叉树，每一层都是填满的。  

下图展示了一个堆以及它的一些特性：  

<img src="./1/dui.jpg">  

特性：当我们知道数组对象i的时候我们就可以确定它的父元素索引在i/2，左子树在2*i，右子树在2*i + 1。  

length[A]：是数组中的元素个数  

heap-size[A]：存放在A中的堆的元素个数  

二叉堆有两种，最大堆和最小堆。  

最大堆，在最大堆中，最大堆特性是指除了根以外的每个结点i，最大元素在根节点，有：  

A[PARENT(i)] >= A[i](最大堆中每根节点都大于等于叶子节点)  


最小堆，在最小堆中，最小堆特性是指除了根以外的每个结点i，最小元素在跟几点，有：  
A[PARENT(i)] <= A[i](最小堆中每叶子节点都大于等于根节点)    

堆的基本操作：  

- MAX-HEAPIFY过程，运行时间为O(lgn)，含义为i作为根节点的最大堆，是保持最大堆的关键性质。  

- BUILD-MAX-HEAP过程，数组线性输入，构造出最大堆。  

- HEAPSPORT过程，运行时间为O(nlgn)，对一个数组原地进行排序

- MAX-HEAP-INSERT  

堆基本操作的实现：  

1. MAX-HEAPIFY算法导论中描述：   

<img src="./1/MAX-HEAPIFY.jpg">  

递归可以理解为A[i],LEFT[i],RIGHT[i]，思路通过largest记录一个最大值，如果largest=说明没有变化，如果largest != i 说明改变交互值，如果i和largest进行了值交换说明largets下面的叶子节点可能也要变动，所以进行递归。  

js实现：
```
function MaxHeapify(arr, i) {
    const left = 2 * i;
    const right = 2 * i + 1;
    const len = arr.length;
    let largest = i;
    if (left <= len && arr[left] > arr[i]) {
        largest = left;
    }
    if (right <= len> && arr[right] > arr[i]) {
        largest = right;
    }
    if (largest !== i) {
        swap(arr, i, largest);
        MaxHeapify(arr, largest);
    }
}
function swap(arr, i, largest) {
    const temp = arr[i];
    arr[i] = arr[largest];
    arr[largest] = temp;
}
```  

2. BUILD-MAX-HEAP算法导论中描述：  

<img src="./1/BUILD_MAX_HEAP.jpg">  



eg1：在高度为h的堆中，最多和最少的元素个数是多少？  

```
我们可以发现堆实际上是一种等比数列，1，2，4，8。。。。2^n   

当h为1的时候，2^0   
当h为2的时候，2^1
......
当为h的时候，2^(h-1)  
公比为2
所以总共元素个数为：  
公式一：s = 2^0 + 2^1 + ..... + 2^(h - 1) 
公式二：s * 2 = 2^1 + ..... + 2^(h - 1) + 2^h
公式二 - 公式一 = s*2 - s = 2^h - 2^0
s = 2^h - 1
```